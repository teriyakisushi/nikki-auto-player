### Melody

#### Required Fields

```txt
---
music_name: Call of Silence
nkver: 2.0
instrument: violin
bpm: 90
timeSig: 4/4
---
@@ Line1
| 3# - 2# - | 1# - 7 - | 6 - 5 - | 6 - 7 - | 1# - 7 - | 6 - 5 - | 4 - 3 - |
...
```

1. 使用 `---` 作为分隔符，分隔出文件的头部和内容部分。
2. 头部区域使用 `:` 作为分隔符，分隔出键值对。

头部为必须字段，为空将使用默认值，头部的字段包含：

| field      | default value | description           |
| ---------- | ------------- | --------------------- |
| music_name | Untitled      | 歌曲名称              |
| nkver      | 2.0           | Nikki Auto Player版本 |
| instrument | violin        | 乐器名称              |
| bpm        | 120           | 每分钟节拍数          |
| timeSig    | 4/4           | 拍号                  |
| humanize   | false         | 模拟人类演奏的随机性  |



- `music_name`：歌曲名称，默认为 `Untitled`。
- `nkver`：Nikki Auto Player版本，如果文件顶部含`---`则默认为 `2.0`，否则默认为 `1.0`
- `instrument`：乐器名称，默认为 `violin` （不会对该字段进行验证，仅用于用户区分）
- `bpm`: 默认为 `120`
- `timeSig`: Time Signature，默认为 `4/4`
- `humanize`: 默认为 `false`，开启则在演奏时会模拟人类演奏的随机性（如音符的轻微延迟等）


3. 内容区域可用`@@`作为一个Bar，分隔出一行或者一节的音符，演奏时会在控制台输出，以检查节奏（非必须）。

### 音符格式

1. Nikki Auto Player会根据bpm和timeSig来计算音符的时长，用户只需要编写简谱即可。
2. 先确保每行的音符所用都为英文半角字符，音符编写规则如下

#### 基础音符

1. 使用`1~7`表示简谱音符，分别对应`do, re, mi, fa, sol, la, ti`
2. 升音符使用`#`表示，例如`1#`表示`do#`
3. 使用`0`表示休止符
4. 没有特别写明的情况下，音符的时长为1拍(1 beat)

#### 延音符

1. 使用`-`表示延音符，例如`1 -`表示`do`的延音，如果有多个延音符可以使用对应的数量，例如`1 - -`表示`do`的延音2拍，`1 - - -`表示`do`的延音3拍

#### 半音符

1. 使用下划线`_`表示半音符，根据`_`的数量解析为对应的音符，最多支持三十二分音符，如`1____`即表示`do`的三十二分音符。
2. 如果连续演奏的节奏都含同一音符，可以用`()`隔离，在括号尾部添加对应数量的`_`，方便简写，如：`(1# 2 3 4#)__`等价于`1#__ 2__ 3__ 4#__`，即该节奏的音符都为八分音符。
3. 不推荐在括号内添加延音符或附点符号，可能会导致解析错误。

#### 附点符号

1. 在音符后添加`.`表示附点符号，附点符号的时长为音符时长的一半，例如`1.`表示`do`的附点音符，时长为1.5拍。
2. 附点音符可以和半音符一起使用，符号`.`必须紧跟数字或唱名后，如：`1._`，表示`do`的附点半音符，时长为0.75拍。

#### 分割符

1. 乐谱中可以使用`|`作为分割符，表示小节的分隔符，程序读取乐谱时会忽略掉该字符（非必须，在演奏时也不会输出，仅用于编写时的可读性）


### 解析

编写如上格式的二进制可读乐谱文件后，程序会将其解析为`.json`文件，头部字段为：

```json
{
  "music_name": "Call of Silence",
  "nkver": "2.0",
  "instrument": "violin",
  "bpm": 90,
  "timeSig": "4/4"
}
```

乐谱内容部分存进`melody`字段，程序会按行，从左往右读取音符内容，顺序存储到`melody`字段中（特殊字符会在程序内部进行解析处理）：

```json
{
   "melody": [
    [
        "@@",
        "Line1",
    ],
    [
        "5#",
        "-"
    ],
    [
        "2#",
        "-"
    ],
   ]
}
```

#### 特殊符号的解析

melody字段下的音符会被解析为一个数组，数组的第一个元素为音符，第二个元素为时长，时长的单位为拍（beat），以下是例子：

0. 一拍的音符将会被存储为：
```json
[
    "5",
    "b",
]
```

1. 延音符，如`5 - - -` 会被存储为：
```json
[
    "5",
    "---",
]
```
2. 半音符，如`5__`会被存储为：
```json
[
    "5",
    "__",
]
```
3. 附点符号，如`5.`会被存储为：
```json
[
    "5",
    ".",
]
```
4. 附点半音符，如`5._`会被存储为：
```json
[
    "5",
    "._",
]
```

可以看出，程序会在读到下一个唱名时，自动将其分割开来，方便后续的解析。(`|`分割符会被忽略掉)

: 程序运行演奏时允许中途改变bpm和timeSig的值，乐谱文件中的音符时长会被重新计算，只需在内容行中写出即可：

- `bpm 150`
- `timeSig 3/4`

以上的行内容将被存储进`melody`字段中，程序在运行时会自动解析，演奏时将重新计算音符的时值


### Sample

```txt
---
music_name: Call of Silence
nkver: 2.0
instrument: violin
bpm: 90
timeSig: 4/4
---
@@ Line1
| 3# - - - |
@@ Line2
2#. 1# - | 0 1#__ | (1 2#)_ | 2._ 4 |
```

以上乐谱将被解析为:

```json
{
  "music_name": "Call of Silence",
  "nkver": "2.0",
  "instrument": "violin",
  "bpm": 90,
  "timeSig": "4/4",
  "melody": [
    [
        "@@",
        "Line1"
    ],
    [
        "3#",
        "---"
    ],
    [
        "@@",
        "Line2"
    ],
    [
        "2#",
        "."
    ],
    [
        "1#",
        "-"
    ],
    [
        "0",
        "b"
    ],
    [
        "1#",
        "__"
    ],
    [
        "1",
        "_"
    ],
    [
        "2#",
        "_"
    ],
    [
        "2",
        "._"
    ],
    [
        "4",
        "b"
    ]
  ]
}
```

